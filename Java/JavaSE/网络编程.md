![image-20220321155534914](C:\Users\psyco\AppData\Roaming\Typora\typora-user-images\image-20220321155534914.png)

**为什么端口有限，为什么会出现端口冲突**

多用户即时通信

客户端和服务端通信要依赖于对象的方式进行，便于数据处理

一个服务端要和多个客户端连接需要多个socket，为了保证服务端的一个socket被一个客户端一直占有，服务端一旦获取了一个socket就应该启动一个线程，

(真正的通信其实是客户端的一个线程里的socket和服务端的一个线程里的socket连接)

如果一个客户端要进行类似群发消息的操作，就需要得到服务端多个线程里的socket(每个socket对应一个数据通道)来进行给其他客户端发消息，就意味着包含有socket的线程需要用集合进行管理(多线程、高并发)，所以应该有一个管理线程的集合，把启动的线程装入集合中。

而一个客户端也可能与服务端有多个连接，比如一个线程专门进行传递文件，一个专门进行视频聊天的，会有可能一个客户端与服务端有多个数据通道，意味着一个客户端也会有多个线程和一个服务端发生通信，所以客户端也应该有一个管理线程的集合。

服务端

1. 当有客户端连接到服务器后，会得到一个socket
2. 启动一个线程，该线程持有该socket对象，也就是说socket是该线程的一个属性
3. 为了更好的管理线程，需要使用集合 例如HashMap 来管理

客户端

1. 和服务器端通信时使用对象方式，可以使用对象流来读写
2. 当客户端连接到服务端后，也会得到socket
3. 启动一个线程，该线程持有socket
4. 为了更好管理线程，也将该线程放入到一个集合。

一个对象要通过对象流读写，那么这个对象所对应的类需要序列化

```java
private static final long serialVersionUID = 1L;//增强兼容性
```









退出问题：主线程启动了一个和服务端通信无限循环的线程，主线程结束但这个未结束，因此客户端程序无法结束

客户端解决方法：在main线程调用方法，给服务端发送一个退出系统的message，调用System.exit(0)

服务端：服务端和某个客户端通信的线程如果接受到了一个退出系统的message后，把这个线程持有的socket关闭，退出该线程的run方法(退出while)，就是退出线程





私聊实现

客户端：

1. 接受用户希望给某个其他在线用户聊天的内容
2. 将消息构建成Message对象，提供对象的socket发送给服务端
3. 在它的通信线程中，读取发送的message消息，并显示

服务端

1. 可以读取到客户端发送给某个客户的消息
2. 从管理线程的集合中，根据message对象的getterid获取到对应的用户的线程的socket
3. 然后将message对象转发给指定客户

