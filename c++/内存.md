

[TOC]

# 1.内存分区

代码区：存放函数体的二进制代码，由操作系统管理(程序运行前分的区域)

全局区：存放全局变量和静态变量(static)以及const修饰的全局变量

栈区：由编译器自动分配释放(管理生存死亡)，存放函数的参数值，局部变量等

堆区：由程序员分配和释放，若不释放，程序结束后由操作系统回收

四区的意义：赋予不同生命周期，更灵活的编程

**程序运行前有代码区和全局区，运行后有栈区和堆区**

## 程序运行前

程序编译后，生成了exe可执行程序，未执行程序前分为两个区域

代码区：

存放CPU执行的机器指令

代码区是共享的——多次执行程序只执行一份同代码

代码区是只读的——运行时不能修改

全局区：

还包含常量区--局部变量地址和全局变量地址差距很多，全局变量和静态变量、地址较近

该区数据在程序结束后由操作系统释放

局部变量、局部常量不在全局区

全局变量、静态变量、常量(字符串常量，const修饰的全局变量-全局变量)

## 程序运行后

栈区：数据由编译器管理开辟和释放，存放函数的参数值，局部变量等

注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

```c++
int* func(int b)//形参数据也会放在栈区
{
    b = 100;
    int a = 10;//存放在栈区，函数执行完后自动释放
    return &a;//返回局部变量的地址
}

int main()
{
    int * p = func(1);
    cout << *p << endl;
    cout << *p << endl;
    system("pause");
    return 0;
}

输出:
10
2067700104
```

第一次是因为编译器做了保留，第二次错误是因为执行完后数据清空

堆区：由程序员分配和释放，若不释放，程序结束后由操作系统回收

使用new在堆区开辟内存

```c++
int* func()
{
    //new返回内存编号
    //指针本质也是局部变量，放在栈上，指针保存的数据放在堆区
    int * p = new int(10);//指针接收开辟的堆区的内存编号
    return p;
}

int main()
{
    int * p = func();
    cout << *p << endl;
    system("pause");
    return 0;
}

输出:10
```

**指针本质也是局部变量，放在栈上，指针保存的数据放在堆区**

int * p                   堆区    0x0011

栈区 0x0011                      10

把堆区的地址编号用栈上的指针保存住了，* 的时候得到10

```c++
cout << *p << endl;
cout << *p << endl;
cout << *p << endl;
cout << *p << endl;

输出
10
10
10
10
```

数据在堆区还没释放

## new操作符

语法：new 数据类型

delete 地址;

delete[] 数组名; 

### delete 释放 

```c++
int* func()
{
    //在堆区创建整型数据
    //new返回的是改数据类型的指针
    int* p = new int(100);
    return p;
}
void test01()
{
    int* p = func();
    cout << *p << endl;
    cout << *p << endl;
    cout << *p << endl;
}
int main()
{ 
    test01();
    system("pause");
    return 0;
}
```

```
输出：
100
100
100
```

若把test01改为,则仍输出三个数

```c++
void test01()
{
    int* p = func();
    cout << *p << endl;
    cout << *p << endl;
    cout << *p << endl;

    delete p;
    cout << *p << endl;
}
```

### 在堆区开辟数组

new int[10]返回数组首地址

```c++
void test02()
{
    //在堆区创建10给整型数据的数组
    int * arr = new int[10];//10代表有10个元素

    for (int i = 0; i < 10; i++)
    {
        arr[i] = i + 100;//给10给元素赋值100-109
    }

    for (int i = 0; i < 10; i++)
    {
        cout << arr[i] << endl;
    }
}
int main()
{
    test02();
    system("pause");
    return 0;
}
```

释放堆区数组，要加[]

```c++
delete[] arr;
```

# 2.引用

## 基本使用

作用：给变量起别名

语法：数据类型(与原数据类型相同) & 别名 = 原名

`int a = 10;`——有一个4字节大小的内存，存放的数据为10，可用变量a代表这块内存去操作这块内存

```c++
int a = 10;
int &b = a;
b = 20;
cout<< a << endl;

输出：20
```

## 注意事项

1.引用必须初始化`int &b;//error`

2.引用在初始化后不能再改变

```c++
int a = 10;
int c = 20;
int &b = a;
int &b = c;//error
```

3.必须引用一块合法的内存空间

## 引用作函数参数

简化指针修改实参

```c++
//地址传递交换
mySwap01(int * a,int * b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}
int main()
{
    int a = 10;
    int b = 20;
    mySwap01(&a,&b);
    cout << "a=" << a << endl;
    cout << "b=" << b << endl;
    system("pause");
    return 0;
}

输出
    20
    10
```

引用传递，形参会修饰实参

```c++
//引用传递交换
mySwap02(int &a,int &b)
{
    int temp = a;
    a = b;
    b = temp;
}
int main()
{
    int a = 10;
    int b = 20;
    mySwap02(a,b);
    cout << "a=" << a << endl;
    cout << "b=" << b << endl;
    
    system("pause");
    return 0;
}

输出
    20
    10
```

引用传递和地址传递的效果一样

## 引用作函数返回值

> **不要返回局部变量的引用**

```c++
int& test01()
{
    int a = 10;//局部变量存放在栈区，test01执行完后释放
    return a;
}
int main()
{
    int &ref = test01();
    cout << ref << endl;//输出10，因为编译器做了保留
    cout << ref << endl;//输出乱码，因为a内存已经释放
    
    system("pause");
    return 0;
}
```

> ***如果函数的返回值是引用，这个函数的调用可以作为左值存在***

```c++
int& test02()
{
    static int a = 10;//静态变量，存放在全局区，整个程序结束后自动释放
    return a;
}
int main()
{
    int &ref2 = test02();
    cout << ref2 << endl;//输出10
    cout << ref2 << endl;//输出10
    
    test02() = 1000;
    
    cout << ref2 << endl;//输出1000
    
    system("pause");
    return 0;
}
```

## 引用的本质

本质：引用在c++内部实现是一个**指针常量**

```c++
void func(int& ref)
{
    ref = 100;//ref是引用，转换未*ref = 100;

}
```

```c++
int main()
{
    int a = 10;
	int& ref = a;//自动转化未int* const ref = &a;指针常量指针方向不可改，也说明为什么引用不可改
	ref = 20;//*ref = 20;
	func(a);
	return 0;
}
```

## 常量引用

作用：修饰形参，防止误操作





引用必须引用一块合法的内存空间 

```c++
int a = 10;
int & ref = 10;//error 引用必须引用一块合法的内存空间 
```

加上const后不报错

```c++
int a = 10;

//const加上后，编译器将代码修改为 int temp = 10; const int & ref = temp;
const int & ref = 10;//引用的是临时的内存
ref = 20;//error,const 使其变为只读，不可修改

```





const 修饰形参，防止误操作

```c++
void showValue(const int &val)
{
    //val = 1000;//error
    cout << "val = " << val << endl;
}

int main()
{
    int a = 100;
    showValue(a);
    cout << "a = " << a << endl;
}

输出
    val = 100
    a = 100
```

# 函数

## 函数默认参数

定义函数时可以给形参定义默认值

语法：返回值类型 函数名 (参数= 默认值)  { }

```c++
int func(int a,int b,int c)
{
    return a+b+c;
}
int main()
{
    
    cout << func(10,20,30) << endl;
    system("pause");
    return 0;
}
输出
    60
```

如果b有默认值20，c有默认值30

```c++
int func(int a,int b=20,int c=30)
{
    return a+b+c;
}
int main()
{
    cout << func(10) << endl;
    system("pause");
    return 0;
}

输出
    60
```

如果改为

```c++
cout << func(10,30) << endl;
输出：
    70
```

**结论：传了值，则用传的值，没传，用默认值**

注意：

1.如果某个位置有了默认参数，那么从这个位置往后，从左到右都必须有默认值

```c++
int func02(int a,int b=10,int c)//error
{
    return a+b+c;
}
```

2.如果函数声明有默认参数，函数实现就不能有默认参数

——error重定义默认参数，二义性

**声明和实现只能有一个有默认参数，不能同时有**

```c++
int func03(int a=10,int b=10);//函数声明

int func03(int a=10,int b=10)//函数实现//error 重定义默认参数
{
    return a+b;
}

int main()
{
    cout << func03(10,10) << endl;
    return 0;
}
    
    
```

## 函数占位参数

c++中函数的形参列表里可以有占位参数，用来占位，调用函数时必须填补该位置

语法：返回值类型 函数名 (**数据类型**) { }  ——只写数据类型代表占位参数

```c++
void func(int a,int)
{
    cout<<"this is func"<<endl;
}

int main()
{
    //func(10)//error
    func(10,10);
    system("pause");
    return 0;
}

```

占位参数也可以有默认参数

```c++
void func(int a,int = 10)
{
    cout<<"this is func"<<endl;
}
```

## 函数重载

作用：函数名可以相同，提高复用性

函数重载满足条件：

1. 同一个作用域下，例如都在全局作用域下
2. 函数名称相同
3. 函数参数类型不同或者个数不同或者顺序不同

**函数的返回值不可以作为函数重载的条件**





```c++
void func()
{
    cout<<"this is func"<<endl;
}
void func(int a)
{
    cout<<"this is func(int a)!!!"<<endl;
}

int main()
{
    func();
    func(1);
    
    system("pause");
    return 0;
}
```

注意事项：函数返回值不能作为函数重载的条件

```c++
void func()
{
    cout<<"this is func"<<endl;
}
int func()//error
{
    cout<<"this is func"<<endl;
}
int main()
{
    func();
    func();
    
    system("pause");
    return 0;
}
```

### 注意事项

- 引用作为重载条件
- 函数重载碰到函数默认参数

```c++

//引用作为重载条件
void func(int &a)//int &a = 10;不合法
{
    cout<<"this is func(int &a)"<<endl;
}
void func(const int &a)//const int &a = 10;
{
    cout<<"this is func(const int &a)"<<endl;
}
int main()
{
    int a = 20;
    func(a);//调用无const
    func(10);//调用有const
    
    system("pause");
    return 0;
}

输出:
    this is func(int &a)
    this is func(const int &a)    
```

```c++
//函数重载碰到函数默认参数，会出现二义性报错
void func2(int a)
{
    cout<<"this is func2(int a)"<<endl;
}
void func2(int a，int b = 10)
{
    cout<<"this is func2(int a,int b)"<<endl;
}
int main()
{
    
    func2(10);//error 第一个第二个func2都能调用
    
    system("pause");
    return 0;
}

输出：
    
    
    
```

# 4.类和对象

三大特性：封装、继承、多态

## 4.1封装

封装意义：

- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制

语法：class 类名{访问权限：属性  /行为  }

类中的属性和行为称为成员

属性    成员属性 成员变量

行为    成员函数 成员方法



设计圆类，求圆的周长

```c++
#include<iostream>
using namespace std;
const double PI = 3.14;

class Circle
{
	//访问权限
	//公共权限
public:

	//属性
	//半径
	int m_r;

	//行为
	//获取圆的周长
	double caculateZC()
	{
		return 2 * PI * m_r;
	}
};

int main()
{
	//通过圆类创建具体的圆(对象)——实例化
	Circle cl;
	//给圆对象的属性进行赋值
	cl.m_r = 10;

	cout << "圆的周长为：" << cl.caculateZC() << endl;
    
    system("pause");
    return 0;
}
```

